(1) vi = c1 * [0,1]vi_(na interação k -1) + c2 * [0,1](bi - xi(na iteração k -1) + c3 * [0,1] (gi - xi na iteração k -1)



(2) sigmoid function --
	1 / (1 + exp(- V_ij))
"[0,1] é delimitado pela fórmula acima"

página 9 do pdf - 37 do paper

Algorithm 1: Discrete Particle Swarm Optimization for the MLSteiner problem

Input: A labelled, undirected, connected graph G = (V,E,L), with n vertices, m
edges,l labels, and Q(é subconjunto de ) V basic nodes;

Output: A spanning tree T;

Initialization:

- Let C (receber) 0 be a set of colours, initially empty set;
- Let H = (V,E(C)) be the subgraph of G restricted to V and edges with labels in C,
where E(C) = {e [ E: L(e) (pertence a) C};
- Set the size ns of the swarm S;

begin
	- Generate the initial swarm S with positions at random:
	X =[x1,. . .; xns] (recebe) Generate-Swarm-At-Random(G);
	- Update the vector of the best positions B = [b0,b1,b2...bns] recebe X;
	- Extract the best position among all the particles:g* (recebe) Extract-The-Best(S, X);
   repeat
	for i = 1 to ns do
		If i = 1 then
			- Initialize the best position of the social neighbourhood: gi (recebe) l;
		else
			- Update the best position of the social neighbourhood i: gi (recebe) g(i - );
		end
		 Select at random a number between 0 and 1:[0,1] aquele random de antes;

	if random [0,1] está entre [0 , 0.25[ then
		- selected (recebe) xi;
	else if random [0.25 , 0.5[ then
		- selected recebe bi;
	else if [0.5 , 0.75] then
		- selected (recebe) g*;
		- Combine particle i and the selected particle: xi (recebe) Combine (xi, selected);
		- Local -- Search(i,c);
	if|xi| < |bi| then
		- Update the best position of given particle i: bi (recebe) xi;
	end

	if |xi| < |gi| then
		- Update the global best position to date: g* (recebe) xi;
	end 
   end

  until termination conditions;

- Set C (recebe) g*;
- Update H = (V,E(C));
 --- Take any arbitrary spanning tree T of H = (V,E(C)).
end







Página 10 do pdf - 38 do paper



Algorithm 2: Procedure Combine (xi, slected)
- Let Comp(xi) be the number of Steiner components of xi;
- Select a random integer between 0 and |xi|: tridentinho (recebe) random (0,|xi|);
for j (recebe) 1 to tridentinho do
	- select at random a number between 0  and 1: (recebe) random (0,1);

	if random <= 0.5 then
		- Select at random a label c' (pertencente) a xi;
		- Delete label c' from position of the given particle: xi (recebe xi) união {c'};
	else
		-Select at random a label c' (pertencente) selected;
		- Add label c' to the position of the given particle i: xi (recebe) xi união {c'};
	end
end?

- Update Comp(xi);

while Comp(xi) > 1 do
	- Select at random an unused label u (pertencente) (L -xi);
        - Add label u to the position of the given particle i: xi (recebe) xi união {u};
end


	

 ?




